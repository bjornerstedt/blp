
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>SimMarket 0.2 Users Guide</title><meta name="generator" content="MATLAB 8.6"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2016-01-10"><meta name="DC.source" content="documentation.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>SimMarket 0.2 Users Guide</h1><!--introduction--><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Demand estimation</a></li><li><a href="#2">NLDemand estimation</a></li><li><a href="#8">RCDemand estimation</a></li><li><a href="#12">Market class</a></li><li><a href="#18">SimMarket Monte-Carlo</a></li><li><a href="#27">RCDemand Monte-Carlo</a></li><li><a href="#31">Nested logit Monte-Carlo</a></li></ul></div><h2>Demand estimation<a name="1"></a></h2><p>Demand is estimated using the <tt>NLDemand</tt> and <tt>RCDemand</tt> classes. The classes have methods to estimate demand of the respective type.</p><p>Data used in estimation is contained in a Matlab  <a href="matlab:doc('table')">table</a>  object. Tables in Matlab are very similar to datasets in Stata or data frames in R. They can contain categorical/factor and numerical variables. Reference to variables in the table are by their variable names.</p><p>Demand is estimated using the <tt>NLDemand</tt> and <tt>RCDemand</tt> classes.</p><h2>NLDemand estimation<a name="2"></a></h2><p>We will start by describing estimation of nested logit demand. Although the syntax is a little different than with <i>mergersim</i> in Stata, the required fields are the same. We load data including table <tt>dt1</tt>, and provide this table as an input to the demand constructor:</p><pre class="codeinput">load <span class="string">example_data</span>;
demand = NLDemand(dt1);
</pre><p>Here we specify the market and panel id, price, quantity and marketsize (here set to the constant value 1). In addition one can specify a list of exogenous variables to be used in estimation in <tt>demand.var.exog</tt>. A list of variables is specified as a string with variable names separated by spaces.</p><pre class="codeinput">demand.var.market = <span class="string">'marketid'</span>;
demand.var.panel = <span class="string">'productid'</span>;
demand.var.price = <span class="string">'p'</span>;
demand.var.quantity = <span class="string">'q'</span>;
demand.var.marketsize = <span class="string">'constant'</span>;
demand.var.exog = <span class="string">'x'</span>;
</pre><p>There are a number of parameters that can be set in <tt>NLDemand</tt> The most important characteristics are set in <tt>demand.var</tt> and <tt>demand.settings</tt>. In <tt>demand.var</tt>, various variable names in the dataset are specified. One can list the contents of the structure:</p><pre class="codeinput">demand.var
</pre><pre class="codeoutput">
ans = 

  SettingsClass with properties:

         market: 'marketid'
          nests: []
    instruments: []
       quantity: 'q'
     marketsize: 'constant'
          price: 'p'
          endog: []
           exog: 'x'
          panel: 'productid'
         depvar: []

</pre><p>In <tt>demand.settings</tt>, other demand settings are set. Four properties of <tt>NLDemand</tt>.settings concern estimation. The last one, <tt>demand.settings.ces</tt> is used to select CES Demand rather than the default, Unit demand.</p><pre class="codeinput">demand.settings
</pre><pre class="codeoutput">
ans = 

  SettingsClass with properties:

            robust: 1
    estimateMethod: 'gls'
               ces: 0
            nocons: 0
         paneltype: 'fe'

</pre><p>To estimate demand, the <tt>estimate()</tt> method is used. The estimation method used will depend on what has been specified in demand.var and in demand.settings.</p><pre class="codeinput">result = demand.estimate()
</pre><pre class="codeoutput">
result = 

          Coef       Std_err     t_value
         _______    _________    _______

    p    -1.0004    0.0049384    -202.57
    x    0.99692    0.0044678     223.14

</pre><p>The method returns a table with the estimate, as well as putting it and various other information in a demand.results structure.</p><h2>RCDemand estimation<a name="8"></a></h2><p>Estimation of mixed logit is rather similar to nested logit. There are more parameters that one can specify, however. In the following example, we use count instruments to identify an endogenous price variable.</p><pre class="codeinput">load <span class="string">example_data</span>;
demand = RCDemand(dt2);

demand.var.market = <span class="string">'marketid'</span>;
demand.var.panel = <span class="string">'productid'</span>;
demand.var.price = <span class="string">'p'</span>;
demand.var.quantity = <span class="string">'q'</span>;
demand.var.marketsize = <span class="string">'constant'</span>;
demand.var.exog = <span class="string">'x'</span>;
demand.var.instruments = <span class="string">'nprod nprod2'</span>;

demand.var.nonlinear = <span class="string">'x'</span>;
</pre><p>To estimate, the <tt>estimate()</tt> method is invoked:</p><pre class="codeinput">result = demand.estimate()
</pre><pre class="codeoutput">
                                Norm of      First-order 
 Iteration        f(x)          step          optimality   CG-iterations
     0          0.0302698                         0.194                
     1          0.0302698             10          0.194           1
     2          0.0199195            2.5          0.152           0
     3           0.017315       0.017804           0.14           1
     4           0.017315          0.625           0.14           1
     5         0.00270136        0.15625         0.0504           0
     6         0.00110893      0.0390625         0.0314           1
     7        0.000523733      0.0222669         0.0212           1
     8        2.52404e-05      0.0390625        0.00453           1
     9         4.1147e-07     0.00976562       0.000573           1
    10        3.83911e-07     4.8885e-05       0.000554           1
    11         2.9845e-07    0.000163976       0.000489           1
    12        2.95847e-07     0.00244141       0.000485           1
    13        2.60272e-07    7.56488e-05       0.000456           1
    14        2.53687e-07    1.45571e-05       0.000449           1
    15        5.34972e-08    0.000610352       0.000207           1
    16        2.66275e-08    0.000152588       0.000146           1
    17        2.13596e-08     3.8147e-05       0.000131           1
    18        2.01332e-08    9.53674e-06       0.000127           1
    19        1.88032e-08    1.06775e-05       0.000123           1
    20        1.65404e-08    1.90735e-05       0.000115           1
    21        1.61064e-08    3.80434e-06       0.000113           1

Optimization stopped because the relative objective function value is changing
by less than options.TolFun = 1.000000e-09.

Optimization Metric                                         Options
relative change objective =   4.34e-10             TolFun =   1e-09 (selected)


result = 

                  Coef      Std_err     t_value 
                ________    _______    _________

    p           -0.67389     6.6411     -0.10147
    x             1.0087    0.62359       1.6176
    constant     -1.4814     33.281    -0.044513
    rc_x         0.93406     2.2399      0.41702

</pre><p>The demand class <tt>RCDemand</tt> has more settings than <tt>NLDemand</tt></p><pre class="codeinput">demand.settings
</pre><pre class="codeoutput">
ans = 

  SettingsClass with properties:

           maxiter: 100
            robust: 1
    estimateMethod: 'gls'
         quaddraws: 10
              nind: 100
         optimalIV: 0
               ces: 0
       marketdraws: 0
            sigma0: []
            nocons: 0
         paneltype: 'lsdv'
        drawmethod: 'hypercube'

</pre><p>We can for example estimate using quadrature, with optimal instruments:</p><pre class="codeinput">demand.settings.drawmethod = <span class="string">'quadrature'</span>;
demand.settings.optimalIV = true;
result = demand.estimate()
</pre><pre class="codeoutput">
                                Norm of      First-order 
 Iteration        f(x)          step          optimality   CG-iterations
     0         3.5956e-05                       0.00555                
User objective function returned complex; trying a new point...
     1         3.5956e-05             10        0.00555           1
User objective function returned complex; trying a new point...
     2         3.5956e-05            0.5        0.00555           0
User objective function returned complex; trying a new point...
     3         3.5956e-05          0.025        0.00555           0
User objective function returned complex; trying a new point...
     4         3.5956e-05        0.00125        0.00555           0
User objective function returned complex; trying a new point...
     5         3.5956e-05       6.25e-05        0.00555           0
User objective function returned complex; trying a new point...
     6         3.5956e-05      3.125e-06        0.00555           0
User objective function returned complex; trying a new point...
     7         3.5956e-05     1.5625e-07        0.00555           0
User objective function returned complex; trying a new point...
     8         3.5956e-05     7.8125e-09        0.00555           0
User objective function returned complex; trying a new point...
     9         3.5956e-05    3.90625e-10        0.00555           0

Optimization stopped because the norm of the current step, 3.906250e-10, is
less than options.TolX = 1.000000e-09.

Optimization Metric                                    Options
relative norm(step) =   3.91e-10                TolX =   1e-09 (selected)

</pre><pre class="codeoutput error">Error using sfminbx (line 27)
Objective function is undefined at initial point. fminunc cannot continue.

Error in fminunc (line 449)
   [x,FVAL,~,EXITFLAG,OUTPUT,GRAD,HESSIAN] = sfminbx(funfcn,x,l,u, ...

Error in RCDemand/minimize (line 143)
                [sigma,fval,exitflag] = fminunc(func, obj.sigma, options);

Error in RCDemand/estimationStep (line 206)
            obj.sigma = obj.minimize([{'Display','iter-detailed'}, varargin]);

Error in RCDemand/estimate (line 197)
                R = obj.estimationStep(true, varargin{:});

Error in documentation (line 100)
result = demand.estimate()
</pre><h2>Market class<a name="12"></a></h2><p>The market class is used to calculate equilibrium prices and quantities, based on market structure. The equilibrium depends on the estimated parameters of the demand model specified.</p><pre class="codeinput">demand2 = copy(demand);
market = Market(demand);
market.var.firm = <span class="string">'firm'</span>;
</pre><p>Here we specify single product firms (corresponding to the product id). To find the marginal costs that correspond with the estimated demand and prices and quantities, we use the function <tt>findCosts()</tt>:</p><pre class="codeinput">market.findCosts();
averageCosts = mean(market.c)
market.summary()
market.summary(<span class="string">'selection'</span>, dt2.marketid == 1)
</pre><p>Having determined costs, one can use the market class (with its associated demand) to study variations in ownership, costs etc. The simplest way to do this is to make a copy of the <tt>Market</tt> object <tt>market</tt> and compute a new equilibrium with the copy, <tt>market2</tt>. The effects of the change in the market conditions in the two settings can then be compared using <tt>market.compare()</tt>.</p><pre class="codeinput">market2 = copy(market);
market2.firm(market2.firm == 2 ) = 1;
market2.equilibrium();
mergerResult = compare(market, market2)
mergerResult = compare(market, market2, <span class="string">'selection'</span>, dt2.marketid == 1)
</pre><p>Cost calculation and equilibrium simulation can be performed on a selection rather than the whole dataset. To do this, a selection vector is provided. In this example we restrict our attention to market 1 by specifying <tt>findCosts(dt2.marketid == 1)</tt>. As costs have not been calculated for other markets, both <tt>market2.equilibrium()</tt> and <tt>compare</tt> calculate only for this market.</p><pre class="codeinput">market = Market(demand2);
market.var.firm = <span class="string">'firm'</span>;
market.findCosts(dt2.marketid == 1);
market2 = copy(market);
market2.firm(market2.firm == 2 ) = 1;
market2.equilibrium();
mergerResult2 = compare(market, market2)
</pre><p>One can also explicitly restrict equilibrium calculation to some markets. In this case calculations will only be on these markets, provided that costs have been calculated for them. Comparisons can be restricted to a subset of markets by providing the restriction with the <tt>'Selection'</tt> option.</p><pre class="language-matlab">market2.equilibrium(dt2.marketid == 1);
mergerResult2 = compare(market, market2, <span class="string">'Selection'</span>, dt2.marketid == 1)
</pre><p>The <tt>Market</tt> class has a number of settings. Similarly to the demand classes, estimation is possible (see section below). One can also specify <tt>market.settings.conduct</tt> - the degree to which profits of other firms are taken in to consideration in profit maximization.</p><h2>SimMarket Monte-Carlo<a name="18"></a></h2><p>To create a simulated market, the <tt>SimMarket</tt> class is used. It has methods to create price and quantity variables: # from a random price using a specified demand # from a set of products that vary exogenously over time</p><p>In both cases instruments are created.</p><p>The purpose of the <tt>SimMarket</tt> class is to # create a dataset based on a demand model and to # facilitate estimation by creating a new demand object associated with the data.</p><pre class="codeinput">m1 = SimMarket()
</pre><p>The <tt>SimMarket</tt> object <tt>m1</tt> contains a structure of settings <tt>m1.model</tt>. The dataset created by <tt>SimMarket</tt> is stored in <tt>m.data</tt>.</p><p>A demand model can be created by using one of the classes <tt>NLDemand</tt> or <tt>RCDemand</tt>. The demand object is created as follows:</p><pre class="codeinput">demand = NLDemand();
demand.alpha = 1;
</pre><p>This command creates an unnested logit demand object, as the only property set is demand.alpha.</p><p>To create a simulated dataset with 100 observations based on the demand object, a <tt>SimMarket</tt> object is created, and the demand object is attached</p><pre class="codeinput">m1.demand = demand;
</pre><p>To create the dataset the method <tt>create()</tt> is used. Invoking this method, changes the <tt>SimMarket</tt> object we have created.</p><pre class="codeinput">sresults = m1.create()
</pre><p>The object <tt>m</tt> now contains a dataset <tt>m1.data</tt>. By default <tt>m1.create()</tt> ceates a market with 5 products and 100 markets, in long format as a Matlab table. The first 10 observations of the dataset are shown below. It contains a market and product identifiers, a constant, costs <tt>c</tt>, a demand characteristic <tt>x</tt> and a variable <tt>d</tt> containing both observable and unobservable characteristics. By default, the disturbances containing both an individual and a product specific shock, the latter uncorrelated with observables (random effects).</p><p>Using the demand specification in <tt>m1.demand</tt>, quantities are calculated based on prices and product characteristics <tt>d</tt>. The total share of the product including the outside good is shown below, as are the average prices and quantities by product. (By default market size is set to 1 in all markets).</p><pre class="codeinput">m1.data(1:10,:)
</pre><p>Once <tt>m1.create()</tt> has been run, a data table has been created for the market that can be used in estimation.</p><pre class="codeinput">dt1 = m1.data;
</pre><p><tt>SimMarket</tt> has an <tt>estimate()</tt> method that can be used to estimate demand based on the data created. It estimates the demand based on a copy of the demand object that has specified.</p><p>Demand can be estimated using the estimate() method. With the standard configuration used here, this gives an OLS panel estimate, using fixed effects. The results shown have true values in the first column and the estimated values in the other columns. This is useful in testing estimation methods.</p><pre class="codeinput">results = m1.estimate()
</pre><h2>RCDemand Monte-Carlo<a name="27"></a></h2><p>Now we will create a slightly more complex market with mixed logit demand. A minimal definition of a <tt>RCDemand</tt> object is as follows:</p><pre class="codeinput">demand = RCDemand();
demand.alpha = 1;
demand.sigma = 1;
demand.var.nonlinear = <span class="string">'x'</span>;
</pre><p>The <tt>SimMarket</tt> class has a set of model settings that can be used to customize the simulated market. All model settings have default values:</p><pre class="codeinput">m2 = SimMarket();
m2.demand = demand;
display(m2.model)
</pre><p>In contrast with the previous example, here we let prices be endogenous. Instead of prices being exogenously random, <tt>create()</tt> calculates equilibrium values depending on market conditions in each market. Price variability can comes from cost shifters and/or the number of products being set to be exogenously random. Prices and quantities will depend on the products in the market as well as the ownership structure. Here we set ownership of the five products explicitly with the <tt>m2.model.firm</tt> setting. Note that as <tt>m2.model.randproducts = true</tt> is specified, not all five products will actually exist in all markets.</p><pre class="codeinput">m2.model.endog = true;
m2.model.randproducts = true;
m2.model.firm = [1,1,2,2,3];
m2.create();
</pre><p>The data table created is as above stored in <tt>m2.data</tt>.</p><pre class="codeinput">dt2 = m2.data;
</pre><h2>Nested logit Monte-Carlo<a name="31"></a></h2><p>A minimal nested logit demand specification with the nesting variable <tt>type</tt> is created as follows:</p><pre class="codeinput">demand = NLDemand();
demand.alpha = 0.5;
demand.sigma = 0.5;
demand.var.nests = <span class="string">'type'</span>;
</pre><p>The market created can be specified by modifying the model characteristics. To allow for nests, we can add a categorical variable <tt>type</tt> having 2 distinct values by specifying:</p><pre class="codeinput">m3 = SimMarket();
m3.demand = demand;
m3.model.types = 2;
</pre><p>Prices in <tt>SimMarket</tt> are by default determined by equilibrium conditions, with variation coming from changes in costs and/or the number of products in the market.</p><p>Alternatively, one can let prices be set randomly, with or without correlation with the error term. In this setup, quantities are calculated based on prices that are randomly generated. With endogeneity, a set of valid instruments inst1-inst6 are also generated.</p><pre class="codeinput">m3.model.simulatePrices = false;
</pre><p>By default SimMarket assumes single product firms. We can change this mapping by setting the <tt>model.firms</tt> property. Here we assume that the five products in the model have two owners.</p><pre class="codeinput">m3.model.firm = [1,1,1,2,2];

m3.model.endog = true;
</pre><p>We add a cost shifter <tt>w</tt> by specifying the <tt>model.gamma</tt> parameter.</p><pre class="codeinput">m3.model.gamma = 1;
m3.create();
dt3 = m3.data;
</pre><p>To estimate this model, the nesting variable <tt>type</tt> has to be specified. The same count instruments as above are used. Note that the 2SLS FE panel estimate will have price and log group shares as endogenous variables.</p><pre class="codeinput">demand = NLDemand(dt3);

demand.var.market = <span class="string">'marketid'</span>;
demand.var.panel = <span class="string">'productid'</span>;
demand.var.price = <span class="string">'p'</span>;
demand.var.quantity = <span class="string">'q'</span>;
demand.var.marketsize = <span class="string">'constant'</span>;
demand.var.exog = <span class="string">'x'</span>;

demand.var.nests = <span class="string">'type'</span>;
demand.var.instruments = <span class="string">'inst1 inst2 inst3 inst4 inst5 inst6'</span>;
demand.settings.paneltype = <span class="string">'lsdv'</span>;
result = demand.estimate()
</pre><p>The cost equation can be estimated. The default intercept in generated data is 4 and slope (the <tt>gamma</tt> variable) has been set to 1 in the creation of the dataset.</p><pre class="codeinput">market = Market(demand);
market.var.firm = <span class="string">'firm'</span>;
market.findCosts();
market.y = market.c;
market.var.exog = <span class="string">'w'</span>;
market.var.panel = <span class="string">'productid'</span>;
costEstimate = market.estimate()
</pre><p>The datasets that have been created can be saved for later use, here to the file <tt>example_data.mat</tt>:</p><pre class="codeinput">save <span class="string">example_data</span> <span class="string">dt1</span> <span class="string">dt2</span> <span class="string">dt3</span>;
</pre><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2015b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% SimMarket 0.2 Users Guide

%% Demand estimation
% Demand is estimated using the |NLDemand| and
% |RCDemand| classes. The classes have methods to estimate demand of
% the respective type. 
%
% Data used in estimation is contained in a Matlab  <matlab:doc('table') table>  object. Tables
% in Matlab are very similar to datasets in Stata or data frames in R. They
% can contain categorical/factor and numerical variables. Reference to
% variables in the table are by their variable names. 
%
% Demand is estimated using the |NLDemand| and |RCDemand|
% classes.

%% NLDemand estimation
% We will start by describing estimation of nested logit demand. Although the
% syntax is a little different than with _mergersim_ in Stata, the required fields are
% the same. We load data including table |dt1|, and provide this table as an input to
% the demand constructor:

load example_data;
demand = NLDemand(dt1);

%%
% Here we specify the market and panel id, price, quantity and marketsize
% (here set to the constant value 1). In addition one can specify a list of
% exogenous variables to be used in estimation in |demand.var.exog|. A list
% of variables is specified as a string with variable names separated by
% spaces.

demand.var.market = 'marketid';
demand.var.panel = 'productid';
demand.var.price = 'p';
demand.var.quantity = 'q';
demand.var.marketsize = 'constant';
demand.var.exog = 'x';

%%
% There are a number of parameters that can be set in |NLDemand|
% The most important characteristics are set in |demand.var| and |demand.settings|. In
% |demand.var|, various variable names in the dataset are specified. One
% can list the contents of the structure:

demand.var

%%
% In |demand.settings|, other demand settings are set. Four properties
% of |NLDemand|.settings concern estimation. The last one,
% |demand.settings.ces| is used to select CES Demand rather than the default,
% Unit demand.

demand.settings

%%
% To estimate demand, the |estimate()| method is used. The estimation method 
% used will depend on what has been specified in demand.var and in
% demand.settings. 

result = demand.estimate()

%%
% The method returns a table with the estimate, as well as putting it and
% various other information in a demand.results structure.

%% RCDemand estimation
% Estimation of mixed logit is rather similar to nested logit. There are
% more parameters that one can specify, however. In the following example,
% we use count instruments to identify an endogenous price variable.

load example_data;
demand = RCDemand(dt2);

demand.var.market = 'marketid';
demand.var.panel = 'productid';
demand.var.price = 'p';
demand.var.quantity = 'q';
demand.var.marketsize = 'constant';
demand.var.exog = 'x';
demand.var.instruments = 'nprod nprod2';

demand.var.nonlinear = 'x';

%%
% To estimate, the |estimate()| method is invoked:

result = demand.estimate()

%%
% The demand class |RCDemand| has more settings than
% |NLDemand|

demand.settings

%% 
% We can for example estimate using quadrature, with optimal instruments:

demand.settings.drawmethod = 'quadrature';
demand.settings.optimalIV = true;
result = demand.estimate()

%% Market class
% The market class is used to calculate equilibrium prices and quantities,
% based on market structure. The equilibrium depends on the estimated
% parameters of the demand model specified.

demand2 = copy(demand);
market = Market(demand);
market.var.firm = 'firm';

%%
% Here we specify single product firms (corresponding to the product id).
% To find the marginal costs that correspond with the estimated demand and
% prices and quantities, we use the function |findCosts()|:

market.findCosts();
averageCosts = mean(market.c)
market.summary()
market.summary('selection', dt2.marketid == 1)

%%
% Having determined costs, one can use the market class (with its
% associated demand) to study variations in ownership, costs etc. The
% simplest way to do this is to make a copy of the |Market| object |market| and
% compute a new equilibrium with the copy, |market2|. The effects of the change in
% the market conditions in the two settings can then be compared using |market.compare()|.

market2 = copy(market);
market2.firm(market2.firm == 2 ) = 1;
market2.equilibrium();
mergerResult = compare(market, market2)
mergerResult = compare(market, market2, 'selection', dt2.marketid == 1)

%%
% Cost calculation and equilibrium simulation can be performed on a
% selection rather than the whole dataset. To do this, a selection vector
% is provided. In this example we restrict our attention to market 1 by
% specifying |findCosts(dt2.marketid == 1)|. As costs have not been
% calculated for other markets, both |market2.equilibrium()| and |compare|
% calculate only for this market. 

market = Market(demand2);
market.var.firm = 'firm';
market.findCosts(dt2.marketid == 1);
market2 = copy(market);
market2.firm(market2.firm == 2 ) = 1;
market2.equilibrium();
mergerResult2 = compare(market, market2)

%%
% One can also explicitly restrict 
% equilibrium calculation to some markets. In this case calculations will
% only be on these markets, provided that costs have been calculated for
% them. Comparisons can be restricted to a subset of markets by providing
% the restriction with the |'Selection'| option.
%
%   market2.equilibrium(dt2.marketid == 1);
%   mergerResult2 = compare(market, market2, 'Selection', dt2.marketid == 1)

%%
% The |Market| class has a number of settings. Similarly to the demand
% classes, estimation is possible (see section below). One can also specify
% |market.settings.conduct| - the degree to which profits of other firms are taken in
% to consideration in profit maximization.

%% SimMarket Monte-Carlo
% To create a simulated market, the |SimMarket| class is used. It has methods
% to create price and quantity variables:
% # from a random price using a specified demand
% # from a set of products that vary exogenously over time
% 
% In both cases instruments are created.
% 
% The purpose of the |SimMarket| class is to 
% # create a dataset based on a demand model and to 
% # facilitate estimation by creating a new demand object associated with the data. 

m1 = SimMarket()

%%
% The |SimMarket| object |m1| contains a structure of settings |m1.model|. 
% The dataset created by |SimMarket| is stored in |m.data|.

%% 
% A demand model can be created by using one of the classes
% |NLDemand| or |RCDemand|. The demand object is created as
% follows:

demand = NLDemand();
demand.alpha = 1;

%%
% This command creates an unnested logit demand object, as the only
% property set is demand.alpha.
%
% To create a simulated dataset with 100 observations based on the demand
% object, a |SimMarket| object is created, and the demand object is attached

m1.demand = demand;

%%
% To create the dataset the method |create()| is used. Invoking
% this method, changes the |SimMarket| object we have created. 

sresults = m1.create()

%%
% The object |m| now contains a dataset |m1.data|.
% By default |m1.create()| ceates a market with 5 products and 100 markets, in long 
% format as a Matlab table. 
% The first 10 observations of the dataset are shown below. It contains a 
% market and product identifiers, a constant, costs |c|, a demand characteristic |x| and
% a variable |d| containing both observable and unobservable characteristics. By
% default, the disturbances containing both an individual and a product
% specific shock, the latter uncorrelated with observables (random
% effects).

%%
% Using the demand specification in |m1.demand|, quantities are calculated 
% based on prices and product characteristics |d|. The total
% share of the product including the outside good is shown below, as are
% the average prices and quantities by product. (By default market size is
% set to 1 in all markets).

m1.data(1:10,:)

%%
% Once |m1.create()| has been run, a data table has been created for the
% market that can be used in estimation.

dt1 = m1.data;

%%
% |SimMarket| has an |estimate()| method that can be used to estimate
% demand based on the data created. It estimates the demand based on a copy
% of the demand object that has specified. 
%
% Demand can be estimated using the estimate() method. With the standard
% configuration used here, this gives an OLS panel estimate, using fixed
% effects. The results shown have true values in the first column and the
% estimated values in the other columns. This is useful in testing
% estimation methods.

results = m1.estimate()

%% RCDemand Monte-Carlo
% Now we will create a slightly more complex market with mixed logit demand. 
% A minimal definition of a |RCDemand| object is as follows:

demand = RCDemand();
demand.alpha = 1;
demand.sigma = 1;
demand.var.nonlinear = 'x';

%% 
% The |SimMarket| class has a set of model settings that can be used to
% customize the simulated market. All model settings have default values:

m2 = SimMarket();
m2.demand = demand;
display(m2.model)

%% 
% In contrast with the previous example, here we let prices be endogenous. 
% Instead of prices being exogenously random, |create()| calculates 
% equilibrium values depending on market conditions in each
% market. Price variability can comes from cost shifters and/or the number of products being set to be 
% exogenously random. Prices and quantities will depend on the products in
% the market as well as the ownership structure. Here we set ownership of
% the five products explicitly with the |m2.model.firm| setting. Note that
% as |m2.model.randproducts = true| is specified, not all five products
% will actually exist in all markets.

m2.model.endog = true;
m2.model.randproducts = true;
m2.model.firm = [1,1,2,2,3];
m2.create();

%%
% The data table created is as above stored in |m2.data|. 

dt2 = m2.data;

%% Nested logit Monte-Carlo
% A minimal nested logit demand specification with the nesting variable
% |type| is created as follows:

demand = NLDemand();
demand.alpha = 0.5;
demand.sigma = 0.5;
demand.var.nests = 'type';

%%
% The market created can be specified by modifying the model characteristics. 
% To allow for nests, we can add a categorical variable |type| 
% having 2 distinct values by specifying:

m3 = SimMarket();
m3.demand = demand;
m3.model.types = 2;

%%
% Prices in |SimMarket| are by default determined by
% equilibrium conditions, with variation coming from changes in costs
% and/or the number of products in the market. 
%
% Alternatively, one can let prices be set randomly, with or without
% correlation with the error term. In this setup, quantities are calculated
% based on prices that are randomly generated. With endogeneity, a set of
% valid instruments inst1-inst6 are also generated.

m3.model.simulatePrices = false; 

%%
% By default SimMarket assumes single product firms. We can change this mapping
% by setting the |model.firms| property. Here we assume that the five
% products in the model have two owners. 

m3.model.firm = [1,1,1,2,2];

m3.model.endog = true;

%%
% We add a cost shifter |w| by specifying the |model.gamma| parameter.

m3.model.gamma = 1;
m3.create();
dt3 = m3.data;

%%
% To estimate this model, the nesting variable |type| has to be specified.
% The same count instruments as above are used. Note that the 2SLS FE panel
% estimate will have price and log group shares as endogenous variables.

demand = NLDemand(dt3);

demand.var.market = 'marketid';
demand.var.panel = 'productid';
demand.var.price = 'p';
demand.var.quantity = 'q';
demand.var.marketsize = 'constant';
demand.var.exog = 'x';

demand.var.nests = 'type';
demand.var.instruments = 'inst1 inst2 inst3 inst4 inst5 inst6';
demand.settings.paneltype = 'lsdv';
result = demand.estimate()

%% 
% The cost equation can be estimated. The default intercept in generated data is 4 and slope
% (the |gamma| variable) has been set to 1 in the creation of the dataset.

market = Market(demand);
market.var.firm = 'firm';
market.findCosts();
market.y = market.c;
market.var.exog = 'w';
market.var.panel = 'productid';
costEstimate = market.estimate()

%%
% The datasets that have been created can be saved for later use, here to 
% the file |example_data.mat|:

save example_data dt1 dt2 dt3;


##### SOURCE END #####
--></body></html>