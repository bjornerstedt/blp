
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>SimMarket Reference</title><meta name="generator" content="MATLAB 8.6"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2016-01-07"><meta name="DC.source" content="reference_doc.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>SimMarket Reference</h1><!--introduction--><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Estimate class</a></li><li><a href="#6">NestedLogitDemand class</a></li><li><a href="#9">MixedLogitDemand class</a></li><li><a href="#14">Market class</a></li><li><a href="#17">SimMarket class</a></li></ul></div><h2>Estimate class<a name="1"></a></h2><p>SimMarket demand and market classes all inherit the linear estimation functionality of the <tt>Estimate</tt> class. This class can be used for estimation not directly related to demand or market estimation.</p><pre class="codeinput">load <span class="string">example_data</span>;
est = Estimate(dt3);
</pre><pre class="language-matlab">The <span class="string">Estimate</span> <span class="string">class</span> <span class="string">has</span> <span class="string">the</span> <span class="string">following</span> <span class="string">properties</span>
</pre><pre>  settings: A structure with different estimation settings
   config: Contains less common settings
      var: A structure with variable names used in estimation
     data: The Matlab table with data useed in estimation. Can be
           specified in the constructor as above.</pre><p>In estimating, Estimate creates the following fields</p><pre class="language-matlab">results: A structure <span class="string">with</span> <span class="string">results</span> <span class="string">(coefficients, standare errors, other statistics)</span>
      y: []
      X: []
      Z: []
   beta: []
</pre><pre class="language-matlab">panelid: []
marketid: []
  Xorig: [x]
  Zorig: [x]
</pre><pre class="codeinput">est
</pre><pre class="codeoutput">
est = 

  Estimate with properties:

        data: [500x17 table]
     panelid: []
    marketid: []
     results: [1x1 struct]
           y: []
           X: []
           Z: []
        beta: []
    settings: [1x1 SettingsClass]
      config: [1x1 struct]
         var: [1x1 SettingsClass]
       Xorig: []
       Zorig: []

</pre><p>est.var contains fields for variables used in estimation:</p><pre>        market: Misnomer for this general class - change to time?
         panel: Panel data identifier
        depvar: Dependent variable
          exog: List of exogenous variable names, separated by spaces
         endog: List of endogenous variable
   instruments: List of instruments</pre><pre class="codeinput">est.var
</pre><pre class="codeoutput">
ans = 

  SettingsClass with properties:

          panel: []
          endog: []
         depvar: []
         market: []
    instruments: []
           exog: []

</pre><p>The est.settings structure has the following fields</p><pre>           robust: 1 - robust estimation true/false
        paneltype: 'none' - panel estimate: 'fe'/'lsdv'/'none'
           nocons: 0 Do not include constant in estimation true/false
   estimateMethod: 'ols'/'2sls'/'gmm'</pre><p>est.results</p><pre class="codeinput"><span class="comment">%     estimateDescription: 'Linear Estimate'</span>
<span class="comment">%                   other: [x]</span>
<span class="comment">%                  params: [1x1 struct]</span>
<span class="comment">%                estimate: [2x3 table]</span>
<span class="comment">%                     var: [6x2 table]</span>
<span class="comment">%                settings: [5x2 table]</span>
<span class="comment">%</span>
<span class="comment">%     est.settings.paneltype = 'none';</span>
<span class="comment">%     est.var.exog = 'w';</span>
<span class="comment">%     est.var.depvar = 'c';</span>
<span class="comment">%     est.estimate()</span>

est.settings
</pre><pre class="codeoutput">
ans = 

  SettingsClass with properties:

         paneltype: 'fe'
            robust: 1
    estimateMethod: 'ols'
            nocons: 0

</pre><p>Methods</p><p>Estimation is done with the <tt>estimate()</tt> method. The mehod used depends on the type of object that estimation is performed on. In the <tt>Estimate</tt> class, the method can be set to OLS, 2SLS or GMM in settings.</p><pre class="codeinput">methods(Estimate)
</pre><pre class="codeoutput">
Methods for class Estimate:

Estimate  copy      estimate  init      set       

Call "methods('handle')" for methods of Estimate inherited from handle.

</pre><h2>NestedLogitDemand class<a name="6"></a></h2><p>The demand classes extend <tt>Estimate</tt> to allow estimation of demand systems.</p><pre class="codeinput">demand = NestedLogitDemand(dt1)
demand.var
</pre><pre class="codeoutput">
demand = 

  NestedLogitDemand with properties:

       alpha: []
       sigma: []
           d: []
        data: [500x9 table]
     panelid: []
    marketid: []
     results: [1x1 struct]
           y: []
           X: []
           Z: []
        beta: []
    settings: [1x1 SettingsClass]
      config: [1x1 struct]
         var: [1x1 SettingsClass]
       Xorig: []
       Zorig: []


ans = 

  SettingsClass with properties:

          panel: []
          nests: []
       quantity: []
          endog: []
         depvar: []
         market: []
     marketsize: []
          price: []
    instruments: []
           exog: []

</pre><pre class="language-matlab">NestedLogitDemand <span class="string">has</span> <span class="string">the</span> <span class="string">following</span> <span class="string">additional</span> <span class="string">properties:</span>
</pre><pre>    alpha: The calibrated or estimated alpha parameter
    sigma: A vector with sigmas
         d: A vector with utility shifters, used in Monte Carlo estimation</pre><pre>Additional variables are specified in demand.var:</pre><pre>       price: Variable name of price variable
       nests: Name(s) of nesting variables
    quantity: Quantity variable
  marketsize: Name of variable in dataset containing market size per market</pre><p>There is also an additional setting in NestedLogitDemand beyond those of Estimate:</p><div><ul><li>ces: 0 - Use CES logit rather than unit demand true/false</li></ul></div><pre class="codeinput">demand.settings
</pre><pre class="codeoutput">
ans = 

  SettingsClass with properties:

         paneltype: 'fe'
            robust: 1
    estimateMethod: 'gls'
               ces: 0
            nocons: 0

</pre><p>Methods</p><p>The method <tt>NestedLogitDemand.estimate()</tt> performs a linear panel estimate based on the settings.</p><pre class="codeinput">methods(NestedLogitDemand)
</pre><pre class="codeoutput">
Methods for class NestedLogitDemand:

NestedLogitDemand  estimate           initSimulation     shareJacobian      
actualDemand       getDemand          quantity           shares             
copy               groupElasticities  residuals          
elasticities       init               set                

Call "methods('handle')" for methods of NestedLogitDemand inherited from handle.

</pre><h2>MixedLogitDemand class<a name="9"></a></h2><pre class="codeinput">demand = MixedLogitDemand(dt1)
demand.var
</pre><pre class="codeoutput">
demand = 

  MixedLogitDemand with properties:

    rc_sigma: []
       alpha: []
       sigma: []
           d: []
        data: [500x9 table]
     panelid: []
    marketid: []
     results: [1x1 struct]
           y: []
           X: []
           Z: []
        beta: []
    settings: [1x1 SettingsClass]
      config: [1x1 SettingsClass]
         var: [1x1 SettingsClass]
       Xorig: []
       Zorig: []


ans = 

  SettingsClass with properties:

          nonlinearlogs: []
                  panel: []
                  nests: []
              nonlinear: []
               quantity: []
                  endog: []
                 depvar: []
                 market: []
    nonlineartriangular: []
             marketsize: []
                  price: []
            instruments: []
                   exog: []

</pre><pre>MixedLogitDemand with properties:</pre><pre class="language-matlab">rc_sigma: The calibrated <span class="string">or</span> <span class="string">estimated</span> <span class="string">nonlinear</span> <span class="string">parameters</span>
</pre><p>Settings</p><pre class="language-matlab">SettingsClass <span class="string">with</span> <span class="string">properties:</span>
</pre><pre>            ces: 0 - CES or Unit logit demand
        maxiter: 100 - Maximum number of iterations in optimization
      optimalIV: 0 - Optimal instruments true/false
     drawmethod: 'hypercube' - Sampling method:
     'hypercube'/'quadrature'/'halton'/'random'
           nind: 100 - Number of simulated individuals
    marketdraws: 0 - Different random draws for each market true/false
      quaddraws: 10 - Quadrature accuracy level
   fptolerance1: 1.0000e-14
   fptolerance2: 1.0000e-14</pre><pre class="codeinput">demand.settings
</pre><pre class="codeoutput">
ans = 

  SettingsClass with properties:

              nind: 100
         optimalIV: 0
           maxiter: 100
         quaddraws: 10
      fptolerance1: 1.0000e-14
         paneltype: 'lsdv'
      fptolerance2: 1.0000e-14
       marketdraws: 0
        drawmethod: 'hypercube'
            robust: 1
    estimateMethod: 'gls'
               ces: 0
            nocons: 0

</pre><p>demand.config</p><pre>                hessian: 0
                   test: []
                fpmaxit: 1000
              tolerance: 1.0000e-09
             randstream: []
            restartFval: 1000
             guessdelta: 1
                quietly: 1
   restartMaxIterations: 1</pre><pre class="codeinput">demand.config
</pre><pre class="codeoutput">
ans = 

  SettingsClass with properties:

    restartMaxIterations: 1
                 fpmaxit: 1000
                 quietly: 1
                    test: []
               tolerance: 1.0000e-09
              guessdelta: 1
              randstream: []
                 hessian: 0
             restartFval: 1000

</pre><p>Methods</p><p>The method <tt>MixedLogitDemand.estimate()</tt> performs a BLP estimate based on the settings specified in the demand object.</p><pre class="codeinput">methods(MixedLogitDemand)
</pre><pre class="codeoutput">
Methods for class MixedLogitDemand:

MixedLogitDemand   findDelta          lpart              shareJacobian      
actualDemand       getDemand          minimize           shares             
computeVariance    get_rc_sigma       objective          sharesAll          
copy               groupElasticities  pack               sumstats           
deltaJacobian      init               quantity           
elasticities       initEstimation     randdraws          
estimate           initPeriods        residuals          
estimation_step    initSimulation     set                

Call "methods('handle')" for methods of MixedLogitDemand inherited from handle.

</pre><h2>Market class<a name="14"></a></h2><p>The <tt>Market</tt> class is used to calculate costs or to associated with a demand class either in its constructor or by setting <tt>Market.demand</tt></p><p>demand: Demand object (<tt>NestedLogitDemand</tt> or <tt>MixedLogitDemand</tt>)      p: Equilibrium calculated price      q: Equilibrium calculated quantity     p0: Initial guess for equilibrium price      c: Costs calculated from market prices and quantities and demand estimate</p><p>The <tt>Market</tt> class obtains data and various settings from the associated demand class. List these... It has the settings and var structures allowing estimation of costs.</p><pre class="codeinput">market = Market();
market.var
</pre><pre class="codeoutput">
ans = 

  SettingsClass with properties:

          panel: []
          endog: []
         depvar: []
           firm: []
         market: []
    instruments: []
           exog: []

</pre><p>The Market class has the following settings, set in Market.settings</p><pre>         dampen: 1 - Dampening in fixed point iterations
          maxit: 1000 - Maximum number of iterations in calculating equilibrium
        conduct: 0 - Conduct parameter in [0,1] interval
weightedAverages: 1 - Calculate weighted averages true/false
    valueShares: 0 (1 for CES) - Use value shares as weights</pre><pre class="codeinput">market.settings
</pre><pre class="codeoutput">
ans = 

  SettingsClass with properties:

             conduct: 0
    weightedAverages: 1
              dampen: 1
               maxit: 3000
         valueShares: 0
           paneltype: 'fe'
              robust: 1
      estimateMethod: 'ols'
              nocons: 0

</pre><p>Methods</p><p>Market.findCosts() calculates costs based on a demand specification Prices and quantities used are copied from the demand specification</p><p><tt>Market.equilibrium()</tt> calculates a market equilibrium based on a demand specification, costs, and a specification of ownership and conduct (using <tt>Market.var.firm</tt> and <tt>Market.settings.conduct</tt>.</p><pre class="codeinput">methods(Market)
</pre><pre class="codeoutput">
Methods for class Market:

Market           estimate         focNum           margins          
clone            estimateCosts    getMarketShares  residuals        
compare          findCosts        gmm_estimate     set              
copy             fixedPoint       init             summary          
equilibrium      foc              initSimulation   

Call "methods('handle')" for methods of Market inherited from handle.

</pre><h2>SimMarket class<a name="17"></a></h2><p>In addition to the associated demand object it creates a new demand object <tt>m.estDemand</tt> that is used for estimation.</p><pre>SimMarket has the following properties:</pre><pre>    model: Structure with model settings
     data: Data created by SimMarket
   demand: Demand model specified by user
   market: Market model specified by user</pre><pre class="codeinput">m = SimMarket()
</pre><pre class="codeoutput">
m = 

  SimMarket with properties:

     model: [1x1 struct]
      data: []
    demand: []
    market: []

</pre><p>m.model</p><pre>            endog: 0 - Endogenous prices and quanities true/false
     randproducts: 0 - Exogenously random products in market true/false
   simulatePrices: 1 - Simulate prices or let them be randomly drawn as
                       in Nevo code true/false
          markets: 100 - Number of markets generated
         products: 5 - (Maximum) number of products in each market.
            types: [] - Number of types for each categorical
             firm: [] - Vector of ownership for each producty
             beta: [1 0] -
                x: [5 0] - Expected value for p and other demand shifters
          x_sigma: [1 1] - Variance
                c: 4 - Costs
          c_sigma: 1
            gamma: 0 - Cost shifter parameter
    epsilon_sigma: 0.1 - Sd of individual unobservables
         sigma_xi: 0.1 - Sd of panel unobservables
      endog_sigma: 0.1 - Endogeneity parameter for non simulated prices
        prob_prod: 0.8 - Probability that product exists in a market</pre><pre class="codeinput">m.model
</pre><pre class="codeoutput">
ans = 

             endog: 0
      randproducts: 0
    simulatePrices: 1
           markets: 100
          products: 5
             types: []
              firm: []
              beta: [1 0]
                 x: [5 0]
           x_sigma: [1 1]
                 c: 4
           c_sigma: 1
             gamma: 0
     epsilon_sigma: 0.1000
          sigma_xi: 0.1000
       endog_sigma: 0.1000
         prob_prod: 0.8000

</pre><p>Methods</p><div><ul><li>SimMarket - Create a new simulation object, optionally with demand spec</li><li>create - Creates market - should return dataset.</li><li>estimate -  Estimate and compare, used in testing framework</li><li>findCosts - Calculate costs, used in testing framework</li></ul></div><pre class="codeinput">methods(SimMarket)
</pre><pre class="codeoutput">
Methods for class SimMarket:

SimMarket  copy       create     estimate   findCosts  

Call "methods('handle')" for methods of SimMarket inherited from handle.

</pre><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2015b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% SimMarket Reference

%% Estimate class
% SimMarket demand and market classes all inherit the linear estimation 
% functionality of the |Estimate| class. This class can be used for
% estimation not directly related to demand or market estimation. 

load example_data;
est = Estimate(dt3);

%%
%   The Estimate class has the following properties
% 
%    settings: A structure with different estimation settings
%     config: Contains less common settings
%        var: A structure with variable names used in estimation
%       data: The Matlab table with data useed in estimation. Can be
%             specified in the constructor as above.
%
% In estimating, Estimate creates the following fields
% 
%   results: A structure with results (coefficients, standare errors, other statistics) 
%         y: []
%         X: []
%         Z: []
%      beta: []
%
%   panelid: []
%  marketid: []
%     Xorig: [x]
%     Zorig: [x]

est

%%        
% est.var contains fields for variables used in estimation:
% 
%          market: Misnomer for this general class - change to time?
%           panel: Panel data identifier
%          depvar: Dependent variable
%            exog: List of exogenous variable names, separated by spaces
%           endog: List of endogenous variable
%     instruments: List of instruments
    
est.var

%%
% The est.settings structure has the following fields
%
%             robust: 1 - robust estimation true/false
%          paneltype: 'none' - panel estimate: 'fe'/'lsdv'/'none'
%             nocons: 0 Do not include constant in estimation true/false
%     estimateMethod: 'ols'/'2sls'/'gmm'
%
% est.results
%

%     estimateDescription: 'Linear Estimate'
%                   other: [x]
%                  params: [1x1 struct]
%                estimate: [2x3 table]
%                     var: [6x2 table]
%                settings: [5x2 table]
%                
%     est.settings.paneltype = 'none';
%     est.var.exog = 'w';
%     est.var.depvar = 'c';
%     est.estimate()

est.settings

%%
% Methods
%
% Estimation is done with the |estimate()| method. The mehod used depends
% on the type of object that estimation is performed on. In the |Estimate|
% class, the method can be set to OLS, 2SLS or GMM in settings. 

methods(Estimate)

%% NestedLogitDemand class
%
% The demand classes extend |Estimate| to allow estimation of demand
% systems. 

demand = NestedLogitDemand(dt1)
demand.var

%%
%   NestedLogitDemand has the following additional properties:
% 
%      alpha: The calibrated or estimated alpha parameter
%      sigma: A vector with sigmas
%           d: A vector with utility shifters, used in Monte Carlo estimation
% 
%  Additional variables are specified in demand.var:
% 
%         price: Variable name of price variable
%         nests: Name(s) of nesting variables
%      quantity: Quantity variable
%    marketsize: Name of variable in dataset containing market size per market
%
%
% There is also an additional setting in NestedLogitDemand beyond those of
% Estimate:
% 
% * ces: 0 - Use CES logit rather than unit demand true/false

demand.settings

%% 
% Methods
%
% The method |NestedLogitDemand.estimate()| performs a linear panel
% estimate based on the settings.

methods(NestedLogitDemand)

%% MixedLogitDemand class
%

demand = MixedLogitDemand(dt1)
demand.var

%%
%  MixedLogitDemand with properties:
% 
%   rc_sigma: The calibrated or estimated nonlinear parameters
%        
%% 
% Settings
% 
%   SettingsClass with properties:
% 
%              ces: 0 - CES or Unit logit demand
%          maxiter: 100 - Maximum number of iterations in optimization
%        optimalIV: 0 - Optimal instruments true/false
%       drawmethod: 'hypercube' - Sampling method:
%       'hypercube'/'quadrature'/'halton'/'random'
%             nind: 100 - Number of simulated individuals
%      marketdraws: 0 - Different random draws for each market true/false
%        quaddraws: 10 - Quadrature accuracy level
%     fptolerance1: 1.0000e-14
%     fptolerance2: 1.0000e-14

demand.settings

%%
% demand.config
% 
%                  hessian: 0
%                     test: []
%                  fpmaxit: 1000
%                tolerance: 1.0000e-09
%               randstream: []
%              restartFval: 1000
%               guessdelta: 1
%                  quietly: 1
%     restartMaxIterations: 1

demand.config

%% 
% Methods
%
% The method |MixedLogitDemand.estimate()| performs a BLP
% estimate based on the settings specified in the demand object.

methods(MixedLogitDemand)

%% Market class
% 
% The |Market| class is used to calculate costs or to 
% associated with a demand class either in its
% constructor or by setting |Market.demand|
%
% demand: Demand object (|NestedLogitDemand| or |MixedLogitDemand|)
%      p: Equilibrium calculated price
%      q: Equilibrium calculated quantity
%     p0: Initial guess for equilibrium price
%      c: Costs calculated from market prices and quantities and demand estimate
% 
% The |Market| class obtains data and various settings from the associated
% demand class. List these... It has the settings and var structures allowing estimation of costs. 

market = Market();
market.var

%% 
% The Market class has the following settings, set in Market.settings
% 
%           dampen: 1 - Dampening in fixed point iterations
%            maxit: 1000 - Maximum number of iterations in calculating equilibrium
%          conduct: 0 - Conduct parameter in [0,1] interval
% weightedAverages: 1 - Calculate weighted averages true/false
%      valueShares: 0 (1 for CES) - Use value shares as weights

market.settings

%% 
% Methods
%
% Market.findCosts() calculates costs based on a demand specification
% Prices and quantities used are copied from the demand specification
% 
% |Market.equilibrium()| calculates a market equilibrium based on a demand
% specification, costs, and a specification of ownership and conduct (using
% |Market.var.firm| and |Market.settings.conduct|. 

methods(Market)


%% SimMarket class
% In addition to the associated demand object it creates a new demand object |m.estDemand|
% that is used for estimation. 
%
%  SimMarket has the following properties:
% 
%      model: Structure with model settings
%       data: Data created by SimMarket
%     demand: Demand model specified by user
%     market: Market model specified by user

m = SimMarket()

%% 
% m.model
%
%              endog: 0 - Endogenous prices and quanities true/false
%       randproducts: 0 - Exogenously random products in market true/false
%     simulatePrices: 1 - Simulate prices or let them be randomly drawn as
%                         in Nevo code true/false
%            markets: 100 - Number of markets generated
%           products: 5 - (Maximum) number of products in each market.
%              types: [] - Number of types for each categorical
%               firm: [] - Vector of ownership for each producty
%               beta: [1 0] - 
%                  x: [5 0] - Expected value for p and other demand shifters
%            x_sigma: [1 1] - Variance
%                  c: 4 - Costs
%            c_sigma: 1
%              gamma: 0 - Cost shifter parameter
%      epsilon_sigma: 0.1 - Sd of individual unobservables
%           sigma_xi: 0.1 - Sd of panel unobservables
%        endog_sigma: 0.1 - Endogeneity parameter for non simulated prices
%          prob_prod: 0.8 - Probability that product exists in a market
         
m.model

%% 
% Methods
% 
% * SimMarket - Create a new simulation object, optionally with demand spec       
% * create - Creates market - should return dataset.
% * estimate -  Estimate and compare, used in testing framework
% * findCosts - Calculate costs, used in testing framework

methods(SimMarket)


##### SOURCE END #####
--></body></html>