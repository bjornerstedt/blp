
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>SimMarket 0.3 Reference</title><meta name="generator" content="MATLAB 8.6"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2016-03-04"><meta name="DC.source" content="reference_doc.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>SimMarket 0.3 Reference</h1><!--introduction--><p>This is a preliminary version that includes output of structures for comparisons.</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Estimate class</a></li><li><a href="#10">NLDemand class</a></li><li><a href="#13">RCDemand class</a></li><li><a href="#19">Market class</a></li><li><a href="#27">SimMarket class</a></li></ul></div><h2>Estimate class<a name="1"></a></h2><p>SimMarket demand and market classes all inherit the linear estimation functionality of the <tt>Estimate</tt> class. This class can be used for estimation not directly related to demand or market estimation.</p><pre class="codeinput">load <span class="string">example_data</span>;
est = Estimate(dt3);
</pre><p>The Estimate class has the following properties</p><pre>  settings: A structure with different estimation settings
   config: Contains less common settings
      var: A structure with variable names used in estimation
     data: The Matlab table with data useed in estimation. Can be
           specified in the constructor as above.
  results: A structure with results (coefficients, standare errors, other statistics)</pre><pre class="codeinput">est
</pre><pre class="codeoutput">
est = 

  Estimate with properties:

        data: [403x14 table]
     panelid: []
     results: [1x1 struct]
           y: []
           X: []
           Z: []
        beta: []
    settings: [1x1 SettingsClass]
      config: [1x1 struct]
         var: [1x1 SettingsClass]
       Xorig: []
       Zorig: []

</pre><p>est.var contains fields for variables used in estimation:</p><pre>        market: Misnomer for this general class - change to time?
         panel: Panel data identifier
        depvar: Dependent variable
          exog: List of exogenous variable names, separated by spaces
         endog: List of endogenous variable
   instruments: List of instruments</pre><pre class="codeinput">est.var
</pre><pre class="codeoutput">
ans = 

  SettingsClass with properties:

    instruments: []
           exog: []
         depvar: []
          panel: []
         market: []
          endog: []

</pre><p>The est.settings structure has the following fields</p><pre>           robust: 1 - robust estimation true/false
        paneltype: 'none' - panel estimate: 'fe'/'lsdv'/'none'
           nocons: 0 Do not include constant in estimation true/false
   estimateMethod: 'ols'/'2sls'/'gmm'</pre><pre class="codeinput">est.settings
</pre><pre class="codeoutput">
ans = 

  SettingsClass with properties:

    estimateMethod: 'ols'
            nocons: 0
            robust: 1
         paneltype: 'fe'

</pre><p>The method <tt>Estimate.estimate()</tt> generates a result table as output. It also populates the structure <tt>Estimate.results</tt> with various results</p><p>estimateDescription: 'Linear Estimate'               other: [x]              params: Structure with the estimate and var-covar matrix            estimate: Estimate table                 var: Table with variable names used            settings: Table with settings</p><pre class="codeinput">est.settings.paneltype = <span class="string">'none'</span>;
est.var.exog = <span class="string">'w'</span>;
est.var.depvar = <span class="string">'c'</span>;
est.estimate()
</pre><pre class="codeoutput">
ans = 

                 Coef      Std_err     t_value
                _______    ________    _______

    w           0.98544    0.051983    18.957 
    constant     4.0532    0.048519    83.538 

</pre><p>The complete variance covariance matrix is obtained in the property</p><pre class="codeinput">est.results.params.varcovar
</pre><pre class="codeoutput">
ans = 

                    w        constant 
                _________    _________

    w           0.0027022    0.0001343
    constant    0.0001343    0.0023541

</pre><p>The settings and var structs can also be obtained as tables</p><pre class="codeinput">est.results.var
est.results.settings
</pre><pre class="codeoutput">
ans = 

        names        values
    _____________    ______

    'instruments'    []    
    'exog'           'w'   
    'depvar'         'c'   
    'panel'          []    
    'market'         []    
    'endog'          []    


ans = 

         names          values
    ________________    ______

    'estimateMethod'    'ols' 
    'nocons'            [   0]
    'robust'            [   1]
    'paneltype'         'none'

</pre><p>In estimating, Estimate creates the following properties that can be used in calculations. To generate these properties without estimating, the method <tt>Estimate.init()</tt> is invoked.</p><pre>       y: []
       X: []
       Z: []
    beta: []</pre><pre class="language-matlab">panelid: []
marketid: []
  Xorig: [x]
  Zorig: [x]
</pre><p><b>Methods</b></p><p>Estimation is done with the <tt>estimate()</tt> method. The mehod used depends on the type of object that estimation is performed on. In the <tt>Estimate</tt> class, the method can be set to OLS, 2SLS or GMM in settings.</p><pre class="codeinput">methods(Estimate)
</pre><pre class="codeoutput">
Methods for class Estimate:

Estimate          estimate          set               
copy              init              

Static methods:

countInstruments  demean            

Call "methods('handle')" for methods of Estimate inherited from handle.

</pre><h2>NLDemand class<a name="10"></a></h2><p>The demand classes extend <tt>Estimate</tt> to allow estimation of demand systems.</p><pre class="codeinput">demand = NLDemand(dt1)
demand.var
</pre><pre class="codeoutput">
demand = 

  NLDemand with properties:

       alpha: []
       sigma: []
           d: []
        data: [500x8 table]
     panelid: []
     results: [1x1 struct]
           y: []
           X: []
           Z: []
        beta: []
    settings: [1x1 SettingsClass]
      config: [1x1 struct]
         var: [1x1 SettingsClass]
       Xorig: []
       Zorig: []


ans = 

  SettingsClass with properties:

          nests: []
    instruments: []
           exog: []
     marketsize: []
         depvar: []
          panel: []
         market: []
       quantity: []
          endog: []
          price: []

</pre><p>NLDemand has the following additional properties:</p><pre>    alpha: The calibrated or estimated alpha parameter
    sigma: A vector with sigmas
        d: A vector with utility shifters, used in Monte Carlo estimation</pre><p>Additional variables are specified in demand.var:</p><pre>       price: Variable name of price variable
       nests: Name(s) of nesting variables
    quantity: Quantity variable
  marketsize: Name of variable in dataset containing market size per market</pre><p>There is also an additional setting in NLDemand beyond those of Estimate:</p><div><ul><li>ces: 0 - Use CES logit rather than unit demand true/false</li></ul></div><pre class="codeinput">demand.settings
</pre><pre class="codeoutput">
ans = 

  SettingsClass with properties:

    estimateMethod: '2sls'
            nocons: 0
            robust: 1
         paneltype: 'lsdv'
               ces: 0

</pre><p><b>Methods</b></p><p>The method <tt>NLDemand.estimate()</tt> performs a linear panel estimate based on the settings.</p><pre class="codeinput">methods(NLDemand)
</pre><pre class="codeoutput">
Methods for class NLDemand:

NLDemand           estimate           initSimulation     setTrueResults     
actualDemand       getDemand          quantity           shareJacobian      
copy               groupElasticities  residuals          shares             
elasticities       init               set                

Static methods:

countInstruments   demean             

Call "methods('handle')" for methods of NLDemand inherited from handle.

</pre><h2>RCDemand class<a name="13"></a></h2><pre class="codeinput">demand = RCDemand(dt1)
</pre><pre class="codeoutput">
demand = 

  RCDemand with properties:

       alpha: []
       sigma: []
           d: []
        data: [500x8 table]
     panelid: []
     results: [1x1 struct]
           y: []
           X: []
           Z: []
        beta: []
    settings: [1x1 SettingsClass]
      config: [1x1 SettingsClass]
         var: [1x1 SettingsClass]
       Xorig: []
       Zorig: []

</pre><p>RCDemand with properties:</p><pre>  sigma: The calibrated or estimated nonlinear parameters</pre><p>Settings</p><p>RCDemand.settings has the additional properties:</p><pre>           sigma0: [] - starting point in estimation
       drawmethod: 'hypercube' - Sampling method:
                   ('hypercube'/'quadrature'/'halton'/'random')
        quaddraws: 10 - Quadrature accuracy level
      marketdraws: 0 - Different random draws for each market true/false
             nind: 100 - Number of simulated individuals
          maxiter: 100
        optimalIV: 0 - Optimal instruments true/false</pre><pre class="codeinput">demand.settings
</pre><pre class="codeoutput">
ans = 

  SettingsClass with properties:

         quaddraws: 10
         optimalIV: 0
    estimateMethod: '2sls'
           maxiter: 100
            nocons: 0
            sigma0: []
            robust: 1
         paneltype: 'lsdv'
               ces: 0
       marketdraws: 0
              nind: 100
        drawmethod: 'hypercube'

</pre><p>Various methods can be used for draws of nonlinear variables <tt>demand.settings.drawmethod</tt> can be set as:</p><div><ol><li>'hypercube' - the modified hypercube method of Train et al</li><li>'halton' - halton draws for each nonlinear variable</li><li>'random' - uniform random draws</li><li>'quadrature' - quadrature draws as implemented in the <a href="http://www.mathworks.com">nwspgr method of Heiss &amp; Winschel</a>.</li></ol></div><p>For quadrature, the accuracy can be set using <tt>demand.settings.quaddraws</tt></p><p>For the other methods: hypercube, halton and random, the number of individual draws is set using <tt>demand.settings.nind</tt>.</p><p>The <tt>RCDemand.var</tt> class has the property <tt>nonlinear</tt> to specify the set of nonlinear variables. The nonlinear variables can be specified in different ways, to specify variable names and the type of draw.</p><p>1. As a string of variable names:</p><pre>  demand.var.nonlinear = {'x1 x2', 'normal'};</pre><p>2. As a cell array with variable names and nonlinear distribution:</p><pre>  demand.var.nonlinear = {'x1 x2', 'lognormal'};</pre><p>3. As a cell array with different nonlinear distributions:</p><pre>  demand.var.nonlinear = {{'x1 x2', 'normal'}, {'x3', 'lognormal'}];</pre><p>The set of supported distributions are:</p><div><ol><li>normal: {'x1 x2', 'normal'} or simply {'x1 x2'}</li><li>uniform: {'x1 x2', 'uniform'}</li><li>empirical: {'x1 x2', 'empirical', dataarray}</li><li><i>lognormal</i>:  {'x1 x2', 'lognormal'}</li><li><i>symmetric triangular</i>:  {'x1 x2', 'triangular'}</li><li><i>logistic</i>:  {'x1 x2', 'triangular'}</li></ol></div><p>The lognormal, triangular and logistic distributions cannot be used with the quadrature drawmethod.</p><p>Empirical draws specify an array with weights in the first column and variable values in the other columns.</p><p>RCDemand.config</p><pre>                hessian: 0
                   test: []
                fpmaxit: 1000
              tolerance: 1.0000e-09
             randstream: []
            restartFval: 1000
             guessdelta: 1
                quietly: 1
   restartMaxIterations: 1</pre><pre class="codeinput">demand.config
</pre><pre class="codeoutput">
ans = 

  SettingsClass with properties:

               tolerance: 1.0000e-09
              guessdelta: 1
            fptolerance2: 1.0000e-14
             restartFval: 1000
                 hessian: 0
                    test: []
    restartMaxIterations: 1
                 quietly: 1
                 fpmaxit: 1000
            fptolerance1: 1.0000e-14
                compiled: 1
              randstream: []

</pre><p><b>Methods</b></p><p>The method <tt>RCDemand.estimate()</tt> performs a BLP estimate based on the settings specified in the demand object.</p><pre class="codeinput">methods(RCDemand)
</pre><pre class="codeoutput">
Methods for class RCDemand:

RCDemand           estimationStep     initPeriods        set                
actualDemand       findDelta          initSimulation     setTrueResults     
computeVariance    getDemand          minimize           shareJacobian      
copy               getSigma           objective          shares             
deltaJacobian      groupElasticities  quantity           sharesAll          
elasticities       init               randdraws          
estimate           initEstimation     residuals          

Static methods:

countInstruments   demean             

Call "methods('handle')" for methods of RCDemand inherited from handle.

</pre><h2>Market class<a name="19"></a></h2><p>The <tt>Market</tt> class is used to calculate costs or to associated with a demand class either in its constructor or by setting <tt>Market.demand</tt></p><p>demand: Demand object (<tt>NLDemand</tt> or <tt>RCDemand</tt>)      p: Equilibrium calculated price      q: Equilibrium calculated quantity     p0: Initial guess for equilibrium price      c: Costs calculated from market prices and quantities and demand estimate</p><p>The <tt>Market</tt> class obtains data and various settings from the associated demand class. List these... It has the settings and var structures allowing estimation of costs.</p><pre class="codeinput">market = Market();
market.var
</pre><pre class="codeoutput">
ans = 

  SettingsClass with properties:

    instruments: []
           exog: []
         depvar: []
          panel: []
         market: []
          endog: []
           firm: []

</pre><p><tt>Market.var.firm</tt> is the only property that has to be set to calculate costs or equilibrium.</p><pre class="codeinput">market.var.firm = <span class="string">'productid'</span>;
</pre><p>An estimated or calibrated demand is associated with the marktet either by providing it in the constructor or adding it to the <tt>Market.demand</tt> property:</p><pre class="codeinput">market.demand = demand;
</pre><p>The Market class has the following settings, set in Market.settings</p><pre>         dampen: 1 - Dampening in fixed point iterations
          maxit: 1000 - Maximum number of iterations in calculating equilibrium
        conduct: 0 - Conduct parameter in [0,1] interval
weightedAverages: 1 - Calculate weighted averages true/false
    valueShares: 0 (1 for CES) - Use value shares as weights true/false</pre><pre class="codeinput">market.settings
</pre><pre class="codeoutput">
ans = 

  SettingsClass with properties:

    weightedAverages: 1
             conduct: 0
      estimateMethod: 'ols'
              nocons: 0
              robust: 1
           paneltype: 'fe'
         valueShares: 0
              dampen: 1
               maxit: 3000

</pre><p><b>Methods</b></p><p><tt>Market.findCosts()</tt> calculates costs based on a demand specification Prices and quantities used are copied from the demand specification</p><pre class="language-matlab">market.findCosts()
</pre><p><tt>Market.equilibrium()</tt> calculates a market equilibrium based on a demand specification, costs, and a specification of ownership and conduct (using <tt>Market.var.firm</tt> and <tt>Market.settings.conduct</tt>.</p><pre class="codeinput">methods(Market)
</pre><pre class="codeoutput">
Methods for class Market:

Market            estimateCosts     getMarketShares   set               
clone             estimateGMM       init              summary           
copy              findCosts         initSimulation    
equilibrium       fixedPoint        margins           
estimate          foc               residuals         

Static methods:

countInstruments  demean            

Call "methods('handle')" for methods of Market inherited from handle.

</pre><p>To summarise market calculations after calculating costs with <tt>Market.findCosts()</tt>, <tt>Market.summarise()</tt> can be used. By default weighted averages by firm using market shares as weights are calculated. Market shares by quantity are used by default for unit demand, and market shares by value for CES demand. The type of average can be controlled by setting <tt>Market.settings.weightedAverages</tt> and <tt>Market.settings.valueShares</tt>. One can also summarise a selection in a logical vector by invoking:</p><pre class="language-matlab">m1.summary(<span class="string">'selection'</span>, vec);
</pre><p>Options to functions in Matlab are specified with argument pairs: an identifying text string and a value. To get averages by product for the same selection, one specifies:</p><pre class="language-matlab">m1.summary(<span class="string">'selection'</span>, vec, <span class="string">'GroupingVariables'</span>, <span class="string">'productid'</span>);
</pre><p>The method <tt>Market.summary()</tt> can be used to compare two market equilibria m1 and m2. Aggregated prices and percentage price changes from m1 to m2 are shown. By default weighted average prices, grouped by firm are shown using</p><pre class="language-matlab">summary(m1, m2)
</pre><h2>SimMarket class<a name="27"></a></h2><p>In addition to the associated demand object it creates a new demand object <tt>m.estDemand</tt> that is used for estimation.</p><p>SimMarket has the following properties:</p><pre>model: Structure with model settings
 data: Data created by SimMarket
demand: Demand model specified by user
market: Market model specified by user</pre><pre class="codeinput">m = SimMarket()
</pre><pre class="codeoutput">
m = 

  SimMarket with properties:

     model: [1x1 SettingsClass]
      data: []
    demand: []
    market: []

</pre><p>The market model is specified with the parameters in <tt>SimMarket.model</tt>:</p><pre>         endog: 0 - Endogenous prices and quanities true/false
randomProducts: 0 - Exogenously random products in market true/false
pricesFromCosts: 1 - Simulate prices or let them be randomly drawn as
                   in Nevo code true/false
       markets: 100 - Number of markets generated
      products: 5 - (Maximum) number of products in each market.
         types: [] - Number of types for each categorical
          firm: [] - Vector of ownership for each producty
          beta: [1 0] -
             x: [5 0] - Expected value for p and other demand shifters
         x_vcv: [1 1] - Variance, can be specified as a matrix for
                       multicollinearity
             c: 4 - Costs
         c_vcv: 1
         gamma: 0 - Cost shifter parameter
 epsilon_sigma: 0.1 - Sd of individual unobservables
      sigma_xi: 0.1 - Sd of panel unobservables
   endog_sigma: 0.1 - Endogeneity parameter for non simulated prices
     prob_prod: 0.8 - Probability that product exists in a market</pre><pre class="codeinput">m.model
</pre><pre class="codeoutput">
ans = 

  SettingsClass with properties:

          prob_prod: 0.8000
            epsilon: 0.1000
              types: []
               beta: [1 0]
              w_vcv: 1
              x_vcv: [1 1]
     randomProducts: 0
           products: 5
                  c: 4
              gamma: 0
                 xi: 0.1000
                  w: 0
    pricesFromCosts: 1
                  x: [5 0]
                eta: 1
         varepsilon: 0
          endog_vcv: 0.1000
              endog: 0
               firm: []
            markets: 100

</pre><p><b>Methods</b></p><div><ul><li>SimMarket - Create a new simulation object, optionally with demand spec</li><li>create - Creates market - should return dataset.</li><li>estimate -  Estimate and compare, used in testing framework</li><li>findCosts - Calculate costs, used in testing framework</li></ul></div><pre class="codeinput">methods(SimMarket)
</pre><pre class="codeoutput">
Methods for class SimMarket:

SimMarket  copy       create     findCosts  means      

Static methods:

randDraws  testEqual  testSame   

Call "methods('handle')" for methods of SimMarket inherited from handle.

</pre><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2015b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% SimMarket 0.3 Reference 
% This is a preliminary version that includes output of structures for
% comparisons.

%% Estimate class
% SimMarket demand and market classes all inherit the linear estimation 
% functionality of the |Estimate| class. This class can be used for
% estimation not directly related to demand or market estimation. 
load example_data;
est = Estimate(dt3);

%%
% The Estimate class has the following properties
% 
%    settings: A structure with different estimation settings
%     config: Contains less common settings
%        var: A structure with variable names used in estimation
%       data: The Matlab table with data useed in estimation. Can be
%             specified in the constructor as above.
%    results: A structure with results (coefficients, standare errors, other statistics) 
est

%%        
% est.var contains fields for variables used in estimation:
% 
%          market: Misnomer for this general class - change to time?
%           panel: Panel data identifier
%          depvar: Dependent variable
%            exog: List of exogenous variable names, separated by spaces
%           endog: List of endogenous variable
%     instruments: List of instruments   
est.var

%%
% The est.settings structure has the following fields
%
%             robust: 1 - robust estimation true/false
%          paneltype: 'none' - panel estimate: 'fe'/'lsdv'/'none'
%             nocons: 0 Do not include constant in estimation true/false
%     estimateMethod: 'ols'/'2sls'/'gmm'
est.settings

%% 
% The method |Estimate.estimate()| generates a result table as output. It
% also populates the structure |Estimate.results| with various results
%
% estimateDescription: 'Linear Estimate'
%               other: [x]
%              params: Structure with the estimate and var-covar matrix
%            estimate: Estimate table
%                 var: Table with variable names used
%            settings: Table with settings
est.settings.paneltype = 'none';
est.var.exog = 'w';
est.var.depvar = 'c';
est.estimate()

%%
% The complete variance covariance matrix is obtained in the property
est.results.params.varcovar
%%
% The settings and var structs can also be obtained as tables
est.results.var
est.results.settings

%%
% In estimating, Estimate creates the following properties that can be used in
% calculations. To generate these properties without estimating, the method
% |Estimate.init()| is invoked.
% 
%         y: []
%         X: []
%         Z: []
%      beta: []
%
%   panelid: []
%  marketid: []
%     Xorig: [x]
%     Zorig: [x]


%%
% *Methods*
%
% Estimation is done with the |estimate()| method. The mehod used depends
% on the type of object that estimation is performed on. In the |Estimate|
% class, the method can be set to OLS, 2SLS or GMM in settings. 
methods(Estimate)

%% NLDemand class
%
% The demand classes extend |Estimate| to allow estimation of demand
% systems. 
demand = NLDemand(dt1)
demand.var

%%
% NLDemand has the following additional properties:
% 
%      alpha: The calibrated or estimated alpha parameter
%      sigma: A vector with sigmas
%          d: A vector with utility shifters, used in Monte Carlo estimation
% 
% Additional variables are specified in demand.var:
% 
%         price: Variable name of price variable
%         nests: Name(s) of nesting variables
%      quantity: Quantity variable
%    marketsize: Name of variable in dataset containing market size per market
%
%
% There is also an additional setting in NLDemand beyond those of
% Estimate:
% 
% * ces: 0 - Use CES logit rather than unit demand true/false
demand.settings

%% 
% *Methods*
%
% The method |NLDemand.estimate()| performs a linear panel
% estimate based on the settings.
methods(NLDemand)

%% RCDemand class
%
demand = RCDemand(dt1)

%%
% RCDemand with properties:
% 
%    sigma: The calibrated or estimated nonlinear parameters
%        
%% 
% Settings
% 
% RCDemand.settings has the additional properties:
% 
%             sigma0: [] - starting point in estimation
%         drawmethod: 'hypercube' - Sampling method:
%                     ('hypercube'/'quadrature'/'halton'/'random')
%          quaddraws: 10 - Quadrature accuracy level
%        marketdraws: 0 - Different random draws for each market true/false
%               nind: 100 - Number of simulated individuals
%            maxiter: 100
%          optimalIV: 0 - Optimal instruments true/false

demand.settings

%%
% Various methods can be used for draws of nonlinear variables
% |demand.settings.drawmethod| can be set as:
%
% # 'hypercube' - the modified hypercube method of Train et al
% # 'halton' - halton draws for each nonlinear variable
% # 'random' - uniform random draws
% # 'quadrature' - quadrature draws as implemented in the
% <http://www.mathworks.com nwspgr method of Heiss & Winschel>.
%
% For quadrature, the accuracy can be set using |demand.settings.quaddraws|
%
% For the other methods: hypercube, halton and random, the number of
% individual draws is set using |demand.settings.nind|.
%
% The |RCDemand.var| class has the property |nonlinear| to specify the set
% of nonlinear variables. The nonlinear variables can be specified in
% different ways, to specify variable names and the type of draw.
%
% 1. As a string of variable names:
% 
%    demand.var.nonlinear = {'x1 x2', 'normal'};
%
% 2. As a cell array with variable names and nonlinear distribution:
% 
%    demand.var.nonlinear = {'x1 x2', 'lognormal'};
%
% 3. As a cell array with different nonlinear distributions:
% 
%    demand.var.nonlinear = {{'x1 x2', 'normal'}, {'x3', 'lognormal'}];
%
% The set of supported distributions are:
%
% # normal: {'x1 x2', 'normal'} or simply {'x1 x2'}
% # uniform: {'x1 x2', 'uniform'}
% # empirical: {'x1 x2', 'empirical', dataarray}
% # _lognormal_:  {'x1 x2', 'lognormal'}
% # _symmetric triangular_:  {'x1 x2', 'triangular'}
% # _logistic_:  {'x1 x2', 'triangular'}
%
% The lognormal, triangular and logistic distributions cannot be used with
% the quadrature drawmethod. 
%
% Empirical draws specify an array with weights in the first column and
% variable values in the other columns.

%%
% RCDemand.config
% 
%                  hessian: 0
%                     test: []
%                  fpmaxit: 1000
%                tolerance: 1.0000e-09
%               randstream: []
%              restartFval: 1000
%               guessdelta: 1
%                  quietly: 1
%     restartMaxIterations: 1
demand.config

%% 
% *Methods*
%
% The method |RCDemand.estimate()| performs a BLP
% estimate based on the settings specified in the demand object.
methods(RCDemand)

%% Market class
% 
% The |Market| class is used to calculate costs or to 
% associated with a demand class either in its
% constructor or by setting |Market.demand|
%
% demand: Demand object (|NLDemand| or |RCDemand|)
%      p: Equilibrium calculated price
%      q: Equilibrium calculated quantity
%     p0: Initial guess for equilibrium price
%      c: Costs calculated from market prices and quantities and demand estimate
% 
% The |Market| class obtains data and various settings from the associated
% demand class. List these... It has the settings and var structures allowing estimation of costs. 
market = Market();
market.var

%%
% |Market.var.firm| is the only property that has to be set to calculate
% costs or equilibrium.
market.var.firm = 'productid';
%%
% An estimated or calibrated demand is associated with the marktet either
% by providing it in the constructor or adding it to the |Market.demand|
% property:
market.demand = demand;

%% 
% The Market class has the following settings, set in Market.settings
% 
%           dampen: 1 - Dampening in fixed point iterations
%            maxit: 1000 - Maximum number of iterations in calculating equilibrium
%          conduct: 0 - Conduct parameter in [0,1] interval
% weightedAverages: 1 - Calculate weighted averages true/false
%      valueShares: 0 (1 for CES) - Use value shares as weights true/false
market.settings

%% 
% *Methods*
%
% |Market.findCosts()| calculates costs based on a demand specification
% Prices and quantities used are copied from the demand specification
% 
%   market.findCosts()

%%
% |Market.equilibrium()| calculates a market equilibrium based on a demand
% specification, costs, and a specification of ownership and conduct (using
% |Market.var.firm| and |Market.settings.conduct|. 
methods(Market)

%%
% To summarise market calculations after calculating costs with |Market.findCosts()|, 
% |Market.summarise()| can be used. By default weighted averages by firm using market
% shares as weights are calculated. Market shares by quantity are used by
% default for unit demand, and market shares by value for CES demand. The
% type of average can be controlled by setting
% |Market.settings.weightedAverages| and |Market.settings.valueShares|.
% One can also summarise a selection in a logical vector by invoking:
%
%   m1.summary('selection', vec);
% 
% Options to functions in Matlab are specified with argument pairs: an
% identifying text string and a value. To get averages by product for the
% same selection, one specifies:
%
%   m1.summary('selection', vec, 'GroupingVariables', 'productid'); 

%%
% The method |Market.summary()| can be used to compare two market equilibria 
% m1 and m2. Aggregated prices and percentage price changes from m1 to m2 are shown. 
% By default weighted average prices, grouped by firm are shown using
%
%   summary(m1, m2)
%% SimMarket class
% In addition to the associated demand object it creates a new demand object |m.estDemand|
% that is used for estimation. 
%
% SimMarket has the following properties:
% 
%  model: Structure with model settings
%   data: Data created by SimMarket
% demand: Demand model specified by user
% market: Market model specified by user
m = SimMarket()

%% 
% The market model is specified with the parameters in |SimMarket.model|:
% 
%           endog: 0 - Endogenous prices and quanities true/false
%  randomProducts: 0 - Exogenously random products in market true/false
% pricesFromCosts: 1 - Simulate prices or let them be randomly drawn as
%                     in Nevo code true/false
%         markets: 100 - Number of markets generated
%        products: 5 - (Maximum) number of products in each market.
%           types: [] - Number of types for each categorical
%            firm: [] - Vector of ownership for each producty
%            beta: [1 0] - 
%               x: [5 0] - Expected value for p and other demand shifters
%           x_vcv: [1 1] - Variance, can be specified as a matrix for
%                         multicollinearity
%               c: 4 - Costs
%           c_vcv: 1
%           gamma: 0 - Cost shifter parameter
%   epsilon_sigma: 0.1 - Sd of individual unobservables
%        sigma_xi: 0.1 - Sd of panel unobservables
%     endog_sigma: 0.1 - Endogeneity parameter for non simulated prices
%       prob_prod: 0.8 - Probability that product exists in a market       
m.model

%% 
% *Methods*
% 
% * SimMarket - Create a new simulation object, optionally with demand spec       
% * create - Creates market - should return dataset.
% * estimate -  Estimate and compare, used in testing framework
% * findCosts - Calculate costs, used in testing framework
methods(SimMarket)


##### SOURCE END #####
--></body></html>